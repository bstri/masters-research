This project has several purposes:
	1) Create a matrix class with common operations that supports multi-precision numbers using the gmp lib
	2) Implement the Faddeev-Leverrier algorithm to compute the coefficients of the characteristic equation
	3) Implement a trace algorithm for hollow symmetric matrices
	4) Do all of this faster than Matlab

** Installing GMP **

Note: I do not know how to develop using gmp on windows, as I was never able to get anything to work. 

Good documentation can be found at gmplib.org, including installation parameters for a more customized gmp
- https://gmplib.org/manual/Installing-GMP.html#Installing-GMP
- https://gmplib.org/manual/Build-Options.html#Build-Options
- https://gmplib.org/manual/Headers-and-Libraries.html#Headers-and-Libraries

* Linux Instructions *
	1. wget https://gmplib.org/download/gmp/gmp-6.2.1.tar.xz
	2. tar --xz -xvf gmp-6.1.2.tar.xz
	3. sudo apt-get install m4
	4. cd gmp-6.1.2
	5. ./configure --enable-cxx # configuring with this flag enables c++ support
	6. make
	7. make check
	8. sudo make install

* Mac Instructions *
	I don't know the specific commands needed, but I am told you can use homebrew to install gmp.
	Maybe try:
	brew install gmp

** The demo **

If everything worked correctly, you should be able to run
	make
in the project directory, which will generate (among others) an executable called "demo"

The demo takes in as its only argument an integer n, meaning "use nXn matrices", or a file name containing an integer matrix
If we run
	./demo 4
we see two randomly generated 4X4 integer matrices A and B. 
If we run
	./demo sampleZ.txt
we see the matrix from that file stored as A, and a random matrix B.

The demo will show:
- the result of right multiplying A by B
- the result of the entrywise product of A and B
- the diagonal matrix of A
- the coefficients of A's characteristic equation, as generated by Faddeev-Leverrier (Fadlev for short)
- the lower triangular matrix of A (L) and the coefficients of its characteristic
- the constant coefficient of Fadlev(L) and the determinant of L, as calculated manually (diagonal product)
	- this is to confirm the accuracy of Fadlev, since the constant should equal the determinant up to a minus sign
- the amount of time some of these operations took
For reference, it should take under 10 seconds for demo to run if a 100x100 matrix is used
(Using Matlab's variable precision VPA would take 50-100x as long!)

See the Matrix.h file to find the different ways to construct a multi-precision matrix as well as the different methods you may call on them. 

** The main program **

For running specific functions, you'll want to use ./main
Any call to main will always run the Fadlev algorithm
Main accepts several different flags; here are some examples:
	"./main sampleZ.txt" runs the Fadlev algorithm on the input matrix
	"./main -r=5 -i" runs the Fadlev algorithm on a random 5x5 matrix, and also prints out its inverse
	"./main -q sampleQ.txt -y sampleColumnVector.txt" inputs a rational matrix and a column vector, and solves for x in Ax=y
	"./main sampleHollowSym.txt -h -s" reads in a matrix written in hollow symmetric form and runs a trace algorithm on it
	"./main sampleSym.txt -s -i -f=100" reads in a matrix written in symmetric form and prints out its inverse, using scientific notation with 100 bits of mantissa precision

** The experimental program **

The program called traceMatrixSolve is a very niche program. As input it accepts 4 matrix files to be read as 5x5 hollow symmetric matrices. For each matrix, it computes 4 trace expressions as well as Fadlev. The 4 expressions form a row of a 4x4 matrix (each matrix to a row) called A. x is then solved for in Ax=y, with y a column vector of the last (constant) coefficient of Fadlev for each matrix.
Like main, it accepts -d and -f=n options for debugging and decimal printing.

** Debugging **

For most of the functions, there is no checking to see if the arguments are valid. For example, the trace method assumes a square matrix but will not error if there are more columns than rows. 

When debugging with GDB, the print methods of the Matrix class are useful:
(gdb) call M.PrintMatrix()
(gdb) call M.PrintElement(r, c)
note that to use these functions, optimization should be turned off by compiling with the -O0 option
